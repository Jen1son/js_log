### JS--函数

#### 函数的作用域

1. 函数的定义：

	1. js中有三种作用域：

		1. 全局作用域：变量（全局变量）一直存在，全局可以调用；

		2. 函数作用域：变量（局部变量）只能在函数内部存在；

			1. 函数内部定义的局部变量会覆盖同名的全局变量；

		3. ES6新增块级作用域；

		4. 函数本身的作用域：

			函数本身也是一个值，也有自己的作用域；

			函数的作用域和变量一样，是其声明时所在的作用域，与其运行时所在的作用域无关；

			```javascript
			var a = 1;
			var foo = function () {
			  console.log(a)
			}
			function baz () {
			  var a = 2;
			  foo();
			}
			foo() // 1
			// 函数foo定义在全局作用域上，当其被调用时，它所在的作用域应该为全局作用域，因此使用的变量是全局作用域中的变量a；
			// 函数baz中 定义的局部变量 a 虽然覆盖了 全局变量中的 a ,但是 仅仅只在 函数baz的局部作用域中生效；
			// 因此当 foo 被调用时，foo 的作用域为全局作用域；
			// 函数执行时所在的作用域是定义时的作用域，而不是调用时所在的作用域；
			```

		5. 函数参数：

			1. 函数运行的时候，有时候需要提供外部数据，不同的外部数据得到不同的结果；
			2. 函数的参数也可以解决 上述 函数因为作用域的问题导致的问题；

	2. 函数的闭包：

		1. 闭包：

			正常情况下，函数内定义的局部变量在 函数外是无法访问到的；

			```javascript
			function foo () {
			  var baz = 'jen1son';
			  function bar () {
			    var faz  = 'edwards'
			    console.log (baz)
			  }
			}
			```

			上面例子中 函数 bar 中可以访问到 foo 中定义的变量，但反过来却不行；

			这就是 js 特有的 链式作用域  **chain scope**

			```javascript
			function foo () {
			  var baz = 'jen1son';
			  function bar () {
			    console.log(baz)
			  }
			  return bar
			}
			```

			函数 foo 中定义了一个 bar 函数，bar 函数可以访问到 foo 中的所有数据；

			当函数 foo 将其内部定义的 bar 函数作为返回值返回时，foo函数的外部就可以通过 bar 函数访问到 foo 函数的内部数据了；  

			上例中的 bar 函数就是 **闭包** ；

			本质上讲：闭包就是讲函数内部与函数外部连接起来的一座桥梁；

			闭包最大的用处有两个：

			1. 可以读取函数内部的变量；
			2. 让函数内部的变量一直始终保持在内存中；

			

