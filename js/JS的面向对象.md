### JS--面向对象

####JS的构造方法

1. 典型的面向对象的语言都有 **类** 的概念，类作为 **对象** 的模板；
2. 而js的模板则是 构造函数（constructor）;
   1. 为了区分 构造函数名称的首字母大写；
   2. 函数体内部使用了 **this** 关键字；
   3. 生成对象时，必须使用 **new** 关键字；
```javascript
  let Foo = function () {
    this.baz = 'bar';
  }
```
3. 可以很真实的认为，JS的构造函数就是 定义了一个类；
   1. 类比于高级语言的类而言；
      1. 类中包括 属性&方法；
      2. 生成对象的时候，必须使用 **new** 关键字等；
4. JS构造方法与其他高级语言类的区别：
	1. 构造函数内部的 **this** 指向的是一个新生成的对象；
	2. 所有针对 **this** 的操作都会发生在这个空对象上；
	3. 因此构造函数可以理解为 **对象** 的初始化；因为它新建了一个 **空对象** 然后将 **this** 指向它；最后通过自定义的代码对 **空对象** 进行赋值成想要的对象；
	4. 构造函数作为模板，用来生成实例对象；

####JS的new操作符

1. **new** 命令执行的过程：
	1. 创建一个空对象，作为要返回的对象实例；
	2. 将这个空对象的原型指向构造函数的  **prototype**  属性；
	3. 将这个空对象赋值给函数内部的 **this** 关键字；
	4. 开始执行函数内部的代码；
2. 构造函数中的 **return**
	1. 当 返回的是一个 非对象；定义对象时，会直接忽略；
	2. 当 返回的是 一个对象，那么定义对象的时候，新对象将会是 return 的对象；而不是 this 指向的对象；
	3. 对于 普通的函数（内部没有this），使用 **new** 命令时，会返回一个空对象；
	4. 总结：**new** 总会返回一个对象；要么是实例对象，要么是 **return** 语句指定的对象；

#### JS对象的继承 -- 原型链

1. JS原型对象
	1. 构造函数的缺点：
		1. 同一个构造函数生成的多个对象，无法共享构造函数中定义的属性，造成系统资源的浪费；
		2. 同一个构造函数生成的多个对象，将深拷贝构造函数中定义的方法（对象）；这样很没有必要；
		3. 由同一个构造函数生成的对象，对象与对象之前应该完全共享构造函数中定义的属性&方法；
		4. 解决上述问题的方法 便是 js 的 **原型对象（prototype）**;
	2. prototype属性的作用：
		1. js继承机制的设计思想：构造函数中定义在原型对象上的属性&方法，都能被实例对象共享；
		2. prototype是函数的属性；函数 **不等于** 对象；
		3. js 规定每个函数都有一个 prototype 属性，指向一个对象；
		4. prototype属性对于普通函数来说用处不大；
		5. 对于构造函数来说，prototype属性在生成实例的时候，会自动成为实例对象的原型；

